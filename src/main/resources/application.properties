# don't use dev services, use a real database
quarkus.devservices.enabled=false

quarkus.http.port=8084
quarkus.http.test-port=10084
quarkus.quinoa.dev-server.port=4204

quarkus.datasource.db-kind=mysql
%dev.quarkus.datasource.username=abstrasst
%dev.quarkus.datasource.password=secret
%dev.quarkus.datasource.jdbc.url=jdbc:mysql://localhost:41040/abstrasst

# E2E Testing Profile - Uses H2 in-memory database
%e2e.quarkus.datasource.db-kind=h2
%e2e.quarkus.datasource.jdbc.url=jdbc:h2:mem:e2e;DB_CLOSE_DELAY=-1
%e2e.quarkus.datasource.username=sa
%e2e.quarkus.datasource.password=

quarkus.hibernate-orm.schema-management.strategy=none
%dev.quarkus.hibernate-orm.log.sql=false

quarkus.flyway.migrate-at-start=true

quarkus.log.console.format=%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c{3.}] (%t) [skey:%X{abstratiumkey}] %s%e%n
quarkus.log.level=INFO
%dev.quarkus.log.category."dev.abstratium".level=DEBUG
%dev.quarkus.log.category."io.quarkus.quinoa".level=DEBUG
#%dev.quarkus.log.category."io.quarkus.oidc".level=DEBUG
#%dev.quarkus.log.category."io.quarkus.vertx.http".level=DEBUG
#%dev.quarkus.log.category."io.quarkus.security".level=DEBUG
%dev.quarkus.log.category."io.smallrye.faulttolerance".level=DEBUG

# configures how the UI logs
client.log.level=INFO

# because we are behind proxy. see https://quarkus.io/guides/http-reference#reverse-proxy
quarkus.http.proxy.allow-forwarded=true
quarkus.http.proxy.proxy-address-forwarding=true
quarkus.http.proxy.enable-forwarded-host=true
quarkus.http.proxy.enable-forwarded-prefix=true

# Map the 'groups' claim in JWT to roles for @RolesAllowed
smallrye.jwt.path.groups=groups
smallrye.jwt.claims.groups=groups

# ============================================================================
# OIDC Configuration - BFF Pattern
# ============================================================================
# OIDC is enabled globally to handle /oauth/callback and /api/* endpoints
# Public endpoints use @PermitAll to allow unauthenticated access
# Session cookies are scoped to /api/* to prevent interference with frontend

# BFF tenant configuration
quarkus.oidc.tenant-enabled=true
quarkus.oidc.auth-server-url=https://auth-t.abstratium.dev
%prod.quarkus.oidc.auth-server-url=https://auth.abstratium.dev
# The actual issuer in tokens is different from the auth server URL
quarkus.oidc.token.issuer=https://abstrauth.abstratium.dev

# HTTP Auth Permissions - Define which paths require authentication
# Public paths (no authentication required)
# Note: /oauth/callback is handled internally by Quarkus OIDC and should NOT be in public paths
quarkus.http.auth.permission.public.paths=/public/*
quarkus.http.auth.permission.public.policy=permit

# Protected API paths (authentication required)
quarkus.http.auth.permission.api.paths=/api/*
quarkus.http.auth.permission.api.policy=authenticated

# Note: Frontend routes (/, /index.html, /assets/*, etc.) are served by Quinoa
# and don't need explicit permission config - they're not matched by any policy

# Client credentials
quarkus.oidc.client-id=${ABSTRATIUM_CLIENT_ID:abstratium-abstrasst}
quarkus.oidc.credentials.secret=${ABSTRATIUM_CLIENT_SECRET:dev-secret-CHANGE-IN-PROD}

# Token endpoint authentication - Basic Auth is now supported by TokenResource
# No additional config needed - Quarkus OIDC uses Basic Auth by default

# Application type: web-app (authorization code flow)
quarkus.oidc.application-type=web-app

# PKCE configuration
quarkus.oidc.authentication.pkce-required=true

# Scopes to request (openid is automatically added by Quarkus OIDC)
quarkus.oidc.authentication.scopes=profile,email

# Token verification - disable scope verification since auth server doesn't include scope claim in ID token
#quarkus.oidc.token.verify-access-token-with-user-info=false

# OAuth callback configuration
# The redirect_uri sent to the auth server - must match registered callback URL
quarkus.oidc.authentication.redirect-path=/oauth/callback
# Restore the originally requested path after authentication
quarkus.oidc.authentication.restore-path-after-redirect=true

# Force HTTPS scheme in redirect_uri when behind SSL-terminating reverse proxy
# This ensures redirect_uri uses https:// even when the app receives http:// requests
%dev.quarkus.oidc.authentication.force-redirect-https-scheme=false
%test.quarkus.oidc.authentication.force-redirect-https-scheme=false
%e2e.quarkus.oidc.authentication.force-redirect-https-scheme=false
%prod.quarkus.oidc.authentication.force-redirect-https-scheme=true

# Cookie configuration (HTTP-only, secure, encrypted) - scoped to BFF tenant
quarkus.oidc.token-state-manager.strategy=id-refresh-tokens
quarkus.oidc.token-state-manager.split-tokens=true
quarkus.oidc.token-state-manager.encryption-required=true
quarkus.oidc.token-state-manager.encryption-secret=${COOKIE_ENCRYPTION_SECRET:dev-encryption-key-must-be-at-least-32-chars-long}

# Session timeout - use centralized config (PT15M = 15 minutes = 900 seconds)
quarkus.oidc.authentication.session-age-extension=PT900S

# Cookie settings - Use root path so cookies are available for both /api and /oauth paths
# The state cookie must be accessible at /oauth/callback for OIDC flow to work
quarkus.oidc.authentication.cookie-path=/
# Use Lax instead of Strict to allow cookies on redirects within the same site
# Strict would block the cookie when redirecting from /oauth/callback to /api/auth/login
quarkus.oidc.authentication.cookie-same-site=lax

# Logout configuration
quarkus.oidc.logout.path=/api/auth/logout
quarkus.oidc.logout.post-logout-path=/

# Error handling configuration
quarkus.oidc.authentication.error-path=/api/auth/error

# Forward these paths to Quarkus backend instead of Angular dev server
# /oauth - OAuth callback endpoint used by Quarkus OIDC
# /api - All backend API endpoints
# /public - All backend API endpoints that don't need authentication
# TODO why do i need to keep this list sync with proxy.conf.json?
quarkus.quinoa.ignored-path-prefixes=/oauth,/api,/public

# Quinoa configuration - Angular is in src/main/webui and outputs to dist/abstrasst/browser
quarkus.quinoa.ui-dir=src/main/webui
quarkus.quinoa.build-dir=dist/abstrasst/browser
quarkus.quinoa.enable-spa-routing=true
quarkus.quinoa.package-manager-install=true
quarkus.quinoa.package-manager-install.node-version=24.11.1

# E2E Profile - Ensure Quinoa builds Angular app for e2e tests
%e2e.quarkus.quinoa.package-manager-install=true

# ============================================================================
# CSRF Protection - Custom Implementation
# ============================================================================
# 
# WHY CUSTOM IMPLEMENTATION:
# The quarkus-rest-csrf extension applies globally to ALL POST/PUT/DELETE/PATCH requests,
# with no way to exclude specific paths. This is problematic because:
# 1. OAuth2 login endpoints (on auth.abstratium.dev) already have CSRF protection
#    via the state parameter (server-side validation)
# 2. We want to use HMAC and that requires that the session be known,
#    but it isn't known until after signing in.
#
# CUSTOM IMPLEMENTATION (ApiCsrfFilter + ApiCsrfTokenGenerator):
# - Only applies to /api/* endpoints (OAuth2 flow uses state parameter)
# - Implements Signed Double Submit Cookie pattern with HMAC
# - Token format: base64(hmac).base64(random)
# - HMAC binds token to user's session (principal name)
# - Cookie name: XSRF-TOKEN (matches Angular default)
# - Header name: X-XSRF-TOKEN (matches Angular default)
# - Cookie max-age: Reuses quarkus.oidc.authentication.session-age-extension
# - HttpOnly: false (so Angular can read the cookie)
# - SameSite: Strict
# 
# SECURITY STATUS:
# - OAuth2 flow: Protected by state parameter (server-side validation)
# - /api/* endpoints: Protected by HMAC-signed CSRF tokens
# - Defense in depth: CORS, CSP, SameSite cookies, OIDC authentication

# Enable/disable CSRF protection
csrf.protection.enabled=true
%test.csrf.protection.enabled=false
%e2e.csrf.protection.enabled=true

# HMAC signature key for CSRF tokens (min 32 characters)
# Generate with: openssl rand -base64 64 | tr -d '\n'
csrf.token.signature.key=${CSRF_TOKEN_SIGNATURE_KEY:dev-csrf-key-CHANGE-IN-PRODUCTION-must-be-at-least-32-characters-long-for-security}

# ============================================================================
# CORS Configuration
# ============================================================================

# Enable CORS filter
quarkus.http.cors.enabled=true

# Allowed origins - restrict to your domains
%dev.quarkus.http.cors.origins=http://localhost:4204,http://localhost:8084
%test.quarkus.http.cors.origins=http://localhost:8084
%e2e.quarkus.http.cors.origins=http://localhost:8084
%prod.quarkus.http.cors.origins=https://abstrasst.abstratium.dev

# Allowed methods
quarkus.http.cors.methods=GET,POST,PUT,DELETE,PATCH,OPTIONS

# Allowed headers - include CSRF header
quarkus.http.cors.headers=Content-Type,Authorization,X-XSRF-TOKEN

# Expose headers
quarkus.http.cors.exposed-headers=Content-Disposition

# Allow credentials (required for cookies)
quarkus.http.cors.access-control-allow-credentials=true

# Preflight cache duration
quarkus.http.cors.access-control-max-age=24H

# Security Headers Configuration
# Content Security Policy - Protects against XSS, clickjacking, and code injection
security.csp.enabled=true
security.csp.policy=default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' https://abstratium.dev; font-src 'self'; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self'

# HSTS (HTTP Strict Transport Security) - Forces HTTPS
# Disabled by default (dev/test/e2e use HTTP), enabled in production
security.hsts.enabled=false
security.hsts.max-age=31536000
security.hsts.include-subdomains=true
security.hsts.preload=true

# Enable HSTS in production (requires HTTPS)
%prod.security.hsts.enabled=true

# Disable rate limiting in test profile to avoid interfering with tests
%test.rate-limit.enabled=false
%e2e.rate-limit.enabled=false

# Production: Consider stricter limits
# %prod.rate-limit.oauth.max-requests=5
# %prod.rate-limit.oauth.window-seconds=60
# %prod.rate-limit.oauth.ban-duration-seconds=600

# https://quarkus.io/guides/management-interface-reference
quarkus.management.enabled=true
quarkus.management.host=localhost
quarkus.management.port=9006
quarkus.management.root-path=/m

quarkus.info.enabled=true
quarkus.info.build.enabled=true
quarkus.info.git.enabled=true
quarkus.info.java.enabled=true
quarkus.info.os.enabled=true

# Add custom properties to the build section
quarkus.info.build.app-name=abstrasst

# Build version - injected by Maven during build
build.version=@build.version@

# TODO still required? since it is in the build script
# Native build configuration for CPU compatibility
# Use -march=compatibility to support older CPUs without AVX/AVX2
quarkus.native.additional-build-args=-march=compatibility,-H:+ReportExceptionStackTraces,--initialize-at-run-time=org.eclipse.angus.mail.util.MailLogger
# This will:
# -march=compatibility: Generate code compatible with older x86-64 CPUs (baseline x86-64 instruction set)
# Keep your existing build arguments for exception traces and runtime initialization

# ============================================================================
# OpenTelemetry Observability Configuration
# ============================================================================
# Provides distributed tracing, logging, and metrics with Grafana Loki integration
# See: https://quarkus.io/guides/opentelemetry-tracing
#      https://quarkus.io/guides/opentelemetry-logging

# Application name for telemetry (used as service.name in traces/logs)
quarkus.application.name=abstrasst

# ============================================================================
# OpenTelemetry Tracing Configuration
# ============================================================================
# Tracing is enabled by default when quarkus-opentelemetry is present
# Captures distributed traces across HTTP requests, database calls, etc.

# OTLP exporter endpoint for traces (gRPC protocol)
# Prod: Point to your Grafana Tempo/OTLP collector
%dev.quarkus.otel.exporter.otlp.traces.endpoint=
%prod.quarkus.otel.exporter.otlp.traces.endpoint=${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4317}

# Optional: Add authentication headers for production
# %prod.quarkus.otel.exporter.otlp.traces.headers=authorization=Bearer ${GRAFANA_CLOUD_TOKEN}

# ============================================================================
# OpenTelemetry Logging Configuration
# ============================================================================
# Sends application logs to Loki via OTLP protocol
# Logs are enriched with trace context (traceId, spanId) for correlation

# Enable OpenTelemetry logging
quarkus.otel.logs.enabled=true

# OTLP exporter endpoint for logs (gRPC protocol)
# Prod: Point to your Grafana Loki OTLP endpoint
%dev.quarkus.otel.exporter.otlp.logs.endpoint=
%prod.quarkus.otel.exporter.otlp.logs.endpoint=${OTEL_EXPORTER_OTLP_ENDPOINT:http://localhost:4317}

# Optional: Add authentication headers for production
# %prod.quarkus.otel.exporter.otlp.logs.headers=authorization=Bearer ${GRAFANA_CLOUD_TOKEN}

# ============================================================================
# JDBC Telemetry Configuration
# ============================================================================
# Enables automatic tracing of JDBC queries
# Each SQL statement creates a span with the query text
# See: https://quarkus.io/guides/opentelemetry-tracing#jdbc

# Enable JDBC telemetry to capture SQL statements in traces
quarkus.datasource.jdbc.telemetry=true

# The JDBC telemetry will automatically:
# - Create a span for each database query
# - Include the SQL statement in the span attributes
# - Include database connection details
# - Track query execution time
# - Capture errors and exceptions

# ============================================================================
# Error Handling in Spans
# ============================================================================
# OpenTelemetry automatically enriches spans with error information when exceptions occur
# This includes:
# - Setting span status to ERROR
# - Adding exception.type, exception.message, exception.stacktrace attributes
# - Recording the error event in the span timeline
# No additional configuration needed - this is built into the OpenTelemetry SDK

# ============================================================================
# Additional OpenTelemetry Configuration
# ============================================================================

# Resource attributes (additional metadata attached to all telemetry)
# These help identify and filter data in Grafana
# TODO does this work?
quarkus.otel.resource.attributes=deployment.environment=${DEPLOYMENT_ENV:dev}

# Sampling configuration (default: always sample in dev, configurable in prod)
# For production, consider using probability-based sampling to reduce volume
# %prod.quarkus.otel.traces.sampler=traceidratio
# %prod.quarkus.otel.traces.sampler.arg=0.1

# Propagation format (default: W3C Trace Context)
# This ensures trace context is propagated across service boundaries
quarkus.otel.propagators=tracecontext,baggage

# Disable OpenTelemetry in test profile to avoid interference with tests
%test.quarkus.otel.sdk.disabled=true
%e2e.quarkus.otel.sdk.disabled=true

# ###########################
# LLMs
# ###########################
# enable request/response logging for debugging
quarkus.langchain4j.log-requests=true
quarkus.langchain4j.log-responses=true
%prod.quarkus.langchain4j.log-requests=false
%prod.quarkus.langchain4j.log-responses=false
# openai specifics
quarkus.langchain4j.openai.api-key=${OPENAI_API_KEY}
quarkus.langchain4j.openai."gpt-4.1-nano".api-key=${OPENAI_API_KEY}
quarkus.langchain4j.openai.timeout=180s
# quarkus.langchain4j.chat-model.provider=openai
# quarkus.langchain4j.openai.chat-model.model-name=gpt-4o
# quarkus.langchain4j.openai.chat-model.temperature=0
# quarkus.langchain4j.openai."gpt-4.1-nano".max-tokens=1000
# quarkus.langchain4j.openai.chat-model.include-usage-in-json-stream=true
# quarkus.langchain4j.openai.chat-model.max-tokens=500
# quarkus.langchain4j.openai.chat-model.top-p=0.9
